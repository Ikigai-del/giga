# Шаг 1 - Инициализация проекта & Hello World Servlet

1. Инициализация проекта была выполнена с помощью IntelliJ IDEA. Maven и Java 11 выбраны в качестве основы проекта.
2. Jakarta Servlet API был добавлен в зависимости maven (pom.xml)

> [!NOTE]
> В этом проекте используются Jakarta Servlets (пакет `jakarta`).
> Существуют Java Servlets (пакет `javax`), которые также могут быть использованы для реализации проекта.
> Основным отличием с точки зрения данного проекта является конфликт версий с Tomcat.
> Jakarta Servlets новее Java Servlets и работают с более новыми версиями Tomcat.
> Именно поэтому в данном проекте используется последняя версия Tomcat 10.1.18.

3. Плагин Maven war добавлен для создания `.war` файлов после сборки артефакта, вместо
   стандартного `.jar`. Сервер Tomcat
   работает только с файлами `.war`, поэтому это необходимый шаг.
4. Класс `Main`, сгенерированный по умолчанию, был заменен на `HelloWorldServlet`

> [!NOTE]
> Для того чтобы сервлеты работали, их нужно зарегистрировать или замапить (mapped).
> В данном проекте это делается с помощью аннотации `@WebServlet` в начале класса сервлета.
> Существует также старый способ это сделать - использовать файл дескриптор `web.xml`, который должен быть расположен в
> директории `src/main/webapp/WEB-INF/`.
> Выбирайте, что вам удобнее. Функциональных различий между этими подходами нет

Чтобы запустить проект локально:

- Скачайте и установите Tomcat 10+
- При использовании IntelliJ IDEA Ultimate edition:
    - Отредактируйте/создайте конфигурацию запуска - опция Tomcat Server.
    - Запустите его, должен открыться http://localhost:8080/currency_exchange_rest_api_war/ с выводом "Hello World!".
- При использовании Community edition (или других IDE / редакторов):
    - Соберите артефакт .war с помощью maven
    - Поместите его в необходимую папку в Tomcat (см. документацию Tomcat)

> [!NOTE]
> Для запуска проекта локально при использовании Community Edition также можно использовать:
> - [Плагин Tomcat для Community Edition](https://plugins.jetbrains.com/plugin/9492-smart-tomcat)
> - [Maven плагин Jetty](https://mvnrepository.com/artifact/org.eclipse.jetty/jetty-maven-plugin) для автоматического развертывания артефакта .war на сервере Jetty вместо Tomcat

# Шаг 2 - интеграция SQLite & первый DAO класс

1. Файл `resources/database.db` был создан с помощью команды `sqlite3`.
   Для использования SQLite необходимо сначала скачать его с [официального сайта](https://www.sqlite.org/index.html).
2. Файлы `resources/scripts/*.sql` должны быть исполнены вручную на файле `database.db`.
   В Java-коде нет механизма, который бы делал это автоматически, хотя это возможно сделать

> [!NOTE]
> SQLite имеет меньше типов данных, чем большинство других баз данных.
> Например, в таблице `Currencies` столбец `code` имеет специфическую для SQLite проверку длины, в то время как в других
> БД `VARCHAR(3)`
> было бы достаточно.

3. Добавлена зависимость sqlite-jdbc driver, позволяющая Java-коду взаимодействовать с базой данных SQLite с помощью
   JDBC
4. Добавлена зависимость lombok, чтобы избежать ручного написания шаблонного кода, такого как сеттеры, геттеры,
   конструкторы и т.д.
5. Класс `Currency` представляет сущность в базе данных
6. Интерфейс `CrudDao` определяет, какие общие методы должны быть у каждого класса DAO.
7. Интерфейс `CurrencyDao` определяет, какие операции необходимы для манипулирования сущностью Currency в базе данных
8. Зависимость Hikari Connection Pool была добавлена для облегчения работы с соединениями с базой данных
9. Класс `DatabaseConnectionManager` настраивает `HikariDataSource` и предоставляет `Connection` объекты для операций с
   базой данных классам DAO
10. Класс `JdbcCurrencyDao` инкапсулирует все операции базы данных, связанные с таблицей Currency.

> [!IMPORTANT]
> `JdbcCurrencyDao` использует try-with-resources для каждого метода.
> Важно
> [закрывать connection, statements & result sets](https://docs.oracle.com/javase/tutorial/jdbc/basics/processingsqlstatements.html#closing_connections),
> чтобы они не потребляли ресурсы.
> Это можно сделать, вручную вызвав `close()` в `finally` блоке try-catch или используя try-with-resources, который
> вызывает этот метод автоматически.

> [!IMPORTANT]
> Исключения в `JdbcCurrencyDao` в настоящее время игнорируются.
> Как правило, это плохая практика.
> Обработка исключений будет рассмотрена в следующем шаге.

# Шаг 3 - Работа с валютами & обработка исключений

1. Добавлены `CurrencyRequest` & `CurrencyResponse` DTO классы. Они будут использоваться для формирования запросов и
   ответов API
2. Добавлен [ModelMapper](https://modelmapper.org/). С помощью этой библиотеки можно сократить boilerplate код по
   конвертации DTO в Entity и обратно
3. Добавлены 4 кастомных исключения. Каждое из исключений бросается в определенном случае. Позже, на основе типа
   исключения мы сможем обработать его именно так как надо
4. Класс `ValidationUtils` занимается проверкой DTO объекта, если что-то не так, то кидает кастомное исключение
5. Библиотека jackson добавлена для генерации JSON ответа от API. Используя jackson можно конвертировать Java объект в
   валидную JSON строку с помощью одной строчки Java кода. Это избавляет от необходимости писать такой шаблонный код
   вручную
6. Добавлены сервлеты для работы с валютой

> [!NOTE]
> Сервлеты напрямую вызывают методы слоя работы с данными (DAO).
> Обычно слой контроллеров делегирует эту работу слою сервисов, но на данном этапе проекта это не особо нужно.
> В классах сервисах не будет какой-то бизнес логики, они все также будут вызывать методы DAO классов и просто отдавать
> результат.
> Класс сервис появится в следующем шаге реализации проекта

7. Добавлена обработка исключений в `JdbcCurrencyDao` класс

> [!NOTE]
> Обработка `SQLException` при использовании JDBC может быть непростой задачей
> В [туториале от Oracle](https://docs.oracle.com/javase/tutorial/jdbc/basics/sqlexception.html) можно прочитать, что
> поле SQLState [стандартизировано](https://www.iso.org/standard/76583.html).
> Логичным решением было бы использовать именно его для определения того, что именно случилось с БД.
> Проблема заключается в том, что SQLite, который мы используем в качестве БД, не реализует это поле.
> Поэтому для определения того, что в БД при вставке был нарушен уникальный индекс мы используем
> [коды ошибки специфичные для SQLite](https://www.sqlite.org/rescode.html)

8. `ExceptionHandlerFilter` обрабатывает все кастомные исключения, которые могут возникнуть в ходе работы программы.
   В фильтр запрос поступает до того как он дошел до сервлета. Поэтому написав try-catch блок в фильтре мы добиваемся
   того, что любое исключение выброшенное в сервлете попадет в catch блок фильтра. В этом блоке на основании типа
   исключения формируется ответ с кодом ошибки и сообщением
9. `EncodingFilter` ставит правильную кодировку для ответов и запросов (UTF-8), а также тип ответа API -
   application/json
10. Добавлены ручные тесты для API в виде файла `/requests/currencies.http`. Эти тесты можно прогнать с помощью IDEA
    Ultimate Edition и ее встроенного HTTP клиента. Если вы используете Community Edition или другой редактор кода/IDE,
    то для тестов можно воспользоваться [Postman](https://www.postman.com/) или [Insomnia](https://insomnia.rest/)

# Шаг 4 - Работа с обменными курсами & PATCH запрос

1. Класс `ExchangeRate` представляет сущность в базе данных
2. Интерфейс `ExchangeRateDao` определяет, какие операции необходимы для манипулирования сущностью ExchangeRate в базе
   данных
3. Класс `JdbcExchangeRateDao` инкапсулирует все операции базы данных, связанные с таблицей ExchangeRate.
4. Добавлены `ExchangeRateRequest` & `ExchangeRateResponse` DTO классы. Они будут использоваться для формирования
   запросов и
   ответов API
5. Классы `Mapping` & `Validation` utils обновлены для работы с ExchangeRate сущностями с DTO
6. Класс `ExchangeRateService` инкапсулирует работу с обменными курсами

> [!NOTE]
> Классы DAO принимают в качестве параметров entity объекты.
> Это создает контракт. Любой другой класс, который обращается к DAO должен передать entity объект.
> Именно поэтому в классе сервисе мы формируем объект `ExchangeRate` с помощью вызовов к другому DAO классу.
>
> Можно было поступить по-другому и сделать гибкий DAO класс с SQL запросами на JOIN'ах.
> Тогда и контракт по поводу того, какие параметры нужно передавать в DAO класс бы изменился.
> Каждый подход имеет плюсы и минусы, единственного правильного решения не существует

7. Добавлены сервлеты для работы с обменными курсами

> [!IMPORTANT]
> В Java Servlet API отсутствует поддержка HTTP метода PATCH.
> В `ExchangeRateServlet` необходимо переопределить метод `service()`, который определяет в какой конкретный метод
> сервлета передать запрос, например в `doGet()` или в `doPost()`.
>
> Так как метод PATCH не поддерживается, то и достать параметр `rate` из HTTP запроса с помощью метода `getParameter()`
> не
> получится.
> Обработку параметра `rate` нужно написать вручную

8. Добавлены ручные тесты для API в виде файла `/requests/exchange-rates.http`

# Шаг 5 - Операция обмена валют

1. Добавлены `ExchangeRequest` & `ExchangeResponse` DTO классы. Они будут использоваться для формирования запросов и
   ответов API
2. Добавлен `ExchangeService`, который инкапсулирует логику по обмену валют

> [!NOTE]
> Логика сервиса может показаться сложной, но на самом деле она достаточно простая.
> Например - запрос на обмен `CZK -> PLN`.
> Сначала сервис ищет прямой курс `CZK -> PLN` в БД.
> Если не находит, то ищет `PLN -> CZK`, конвертирует его в прямой курс для последующего обмена.
> Если нет и обратного курса то ищутся два курса - `USD -> CZK` и `USD -> PLN`.
> На их основе составляется прямой `CZK -> PLN` курс.
> Позже, на основе курса, найденного одним из трех способов, происходит обмен и формирование ответа.
>
> Не обязательно следовать именно такому сценарию при реализации этого сервиса

3. Класс `ValidationUtils` обновлен для работы с `ExchangeRequestDto`
4. Добавлен сервлет для работы с операцией обмена валюты